CPU가 데이터를 메모리에 저장하는 방식은 다음과 같이 2가지로 나뉨.

빅 엔디안 방식
리틀 엔디안 방식

빅 엔디안 방식은 상위 바이트의 값을 작은 번지수에 저장 하는것.
리틀 엔디안 방식은 상위 바이트의 값을 큰 번지수에 저장 하는것.

0x12345678을 0x20번지를 시작으로 저장 한다 가정하자. 빅 엔디안 방식에선


0x20번지  0x21번지  0x22번지 0x23번지
0x12      0x34     0x56     0x78

이렇게 저장 된다 반대로 리틀 엔디안 방식에선
0x20번지  0x21번지  0x22번지 0x23번지
0x78      0x56     0x34     0x12

이렇게 됨.  근데 서로 다른 방식을 사용하는 cpu끼리 통신하면 문제가 될 수 있음.

그래서 빅 엔디안 방식으로 통일 하기로함.

리틀 엔디안 시스템에서는 빅 엔디안으로 정렬 해야함.

unsigned short htons(unsigned short);
unsigned short ntohs(unsigned short);
unsigned long htonl(unsigned long);
unsigned long ntohl(unsigned long);

htons에서 h는 호스트(host) 바이트 순서를 의미한다.
htons에서 n은 네트워크(network) 바이트 순서를 의미한다.

그리고 s는 short l은 long를 의미한다.(리눅스에서 long는 4바이트임)

따라서 h, to, n,s 의 조합이니

short형 데이터를 호스트 바이트 순서에서 네트워크 바이트 순서로 변환하라.

ntohs는

short형 데이터를 네트워크 바이트 순서에서 호스트 바이트 순서로 변환해라.

일반적으로 s가 붙는 함수는 s가 2바이트 short를 의미함으로 PORT번호에

l이 붙는건 4바이트를 의미함으로 IP주소의 변환에 사용 된다.

보통 데이터를 주고 받는 과정에서의 빅 엔디안과 리틀 엔디안 변환은 자동으로 이루어 지나

소켓을 생성해서 할당 할때 직접 해줘야 한다.

소켓 생성 다음부터 소켓 통신은 자동으로 변환

소켓 생성할때 할당은 직접.
