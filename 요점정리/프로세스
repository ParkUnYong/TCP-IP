자식 프로세스는 리턴 값이나 exit로 종료 되었을떄 그 값이 운영체제로 가고 부모프로세스가
운영체제로 그 반환값을 참조하면 그재서야 pid가 소멸한다. 그렇지 않으면 소멸 하지 않고 좀비 프로세스가
된다. 

시그널 : 뭔가 신호가 발생했을때 (프로세스와 운영체제간의 약속했던 상황이 발생) 알리는 일종의 메세지 같은것.

SIGNAL : alarm 함수 호출을 통해서 등록된 시간이 다 된 상황
SIGINT : CTRL+C가 입력된 상황
SIGCHLD : 자식 프로세스가 종료된 상황



시그널 핸들링


A프로세스 : 야 프로세스가 종료(1번 상황 발생) 되면 나한테 알려줘 
운영체제 : 알았어. 야 발생했어!
A프로세스  : 알았어 ! 적절한 조치를 할게!

위 상황이 시그널 핸들링임.


시그널 핸들링은 
시그널 발생, 시그널 처리로 이루어져 있다.

원리 

어떤 상황이 발생하면 함수호출. (어떤 상황이 발생하면 그 상황이 발생했음을 알리는 함수 호출)
A프로세스가 운영체제에 이런 상황이 발생하면 이 함수 호출해줘 하고 함수의 주소값을 전달 

그리고 발생하면 운영체제가 등록된 함수 호출. (알리는 상황.)
발생됬을떄의 처리 코드는 등록한 함수내에 정의. 


시그널 함수가 운영체제에 시그널을 등록함.

함수 이름이 시그널. signal(시그널이름,호출할 함수이름)
signal(SIGCHLD,MYCHILD) : 자식 프로세스가 종료되면 mychild 함수 호출.

이것이 바로 시그널 등록임.

슬립함수 호출을 통해 프로세스가 멈춘 상태에 있다 하더라도 
시그널이 발생하면  잠든 상태에서는 시그널을 받아 들일 수 없음.
시그널이 발생이 되면 프로세스에게 알려주기 위해 프로세스를 꺠움.



시그널 발생 -> 프로세스 깨움. 바로 반복문 나와서 다시 안으로 들어감.

for(i=0;i<3;i++)
{
   printf("wait");
   sleep(100);
}

위 코드에서 100초 있다가 빠져 나가지 않고 시그널이 발생되면 바로 포문 탈출.


시그널함수는 과거 코드와 호환성 위해 제공 되는거고 시그널은 운영체제별로 다르게 실행됨.

sigaction (시그널이름,처음에넣은시그널이름이 발생하면 호출할 시그렉션 변수주소,이전에등록된 시그널의 함수포인터 얻는것)

시그액션 구조체 정보 
struct sigaction(
    함수 이름 정보 등록
    sig마스크 : 모든 비트 0 초기화
    sa_flags : 안쓰면 0초기화
    

    

세번째는 지금은 기억할 필요 없고 쓰지 않음. 0 전달.

좀비의 소멸이 목적이기 때문에 첫번째 멤버를 기억. 


우리만 os에 무언갈 전달하는게 아니고 os도 우리에게 뭔 전달 하기도함.

프로세스적 관점에서 



서버와 클라이언트는  엑셉트 함수를 통해 리스닝 소켓을 만들고 

클라이언트의 연결요청도 받고 서비스도 해야 하지만 또 다른 클라이언트가 왔을때

다시 수락을 해줘야함.  즉 프로그램의 흐름이 두개로 나뉘어져야함.

그걸 위해 fork함수 를 사용함. 포크함수로 프로세스를 생성.

프로세스를 이용해서 다른 클라이언트에게 서비스 제공.

클라이언트의 요청을 하나 더 받을 수 있게 되고 자식프로세스로 서비스 제공


포크 함수를 통해 프로세스가 복사 되는 경우 만들어진 소켓이 복사가 되는게 아니고 파일 디스크립터가 복사됨.

즉 소켓 자체는 고대로 하나.  하나의 소켓에 두개의 파일 디스크립터가 존재하는 경우 

두 디스크립터 모두 종료 되어야 해당 소켓이 소멸 하기에 포크 함수 호출 후에는 서로에게 상관 없는

디스크립터는 종료 해야함.


 


