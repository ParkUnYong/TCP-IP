IOCP를 이해 하기 위한 시나리오 

은행원과 고객이 있음. 고객들은 통장 개설을 목적으로 온 사람들.

순서대로 요청을 함. 통장개설을.  

시나리오2

능력있는 은행원  자기의 분신을 만들어내는 능력을 가졌음.

고객들이 우루루 몰려옴.  고객의 수 만큼 분신을 만들어서 

각 고객 별로 실시간으로 서비스를 해줌.

각 분신은 한명이 말하고 있으면 나머지 들은 말을 하지 못함.

고객들은 와서 기다릴 필요 없어서 좋지만 응대가 답답해짐.

시간 대비 서비스의 양이 많지 않은 멀티 스레드 방식의 단점이라 볼 수 있음.


능력있는 은행원 1명이 고객1에게 통장 신청에 필요한 서류를 주고 채우세요 하고
보내고 고객2에게도 이런식으로 서류를 주고 보냄. 다 채운분 있으면 이리 오세요 
하고 처리를 함.   이런 느낌이 IOCP모델의 기본 골자임.

멀티스레드의 형태를 일부 취하지만 IOCP는 스마트한 스레드 하나를 두고서
여러개의 클라이언트의 요청을 처리함.  일을 부여하고 일정 시간이 지난 후 
일 다 했는지 확인 후 새롭게 일을 부여함.

다수의 소켓을 하나의 스레드가 컨트롤을 함.  각각의 요청에 1,2,3번 처리를 해주고
그 일이 끝날떄 까지 뒤로 빼둠. 시간이 지난 후에 다 했냐고 물어보고 다음 일을 
해주는 그런 형식임.


서버 모델은 단순함. 단순하게 해야지 성능이 나옴. 

성능을 위해 간결히 구현된 모델이다 라고 이야기도 함.

클라이언트가 서버에 서비스가 완료 될때까지 걸리는 시간을 세션 타임이라 함.
세션이 상당히 긴 작업임. 동시에 서비스 해야 하는 클라들 그 클라들의 
세션이 긴 경우에는 IOCP가 월등한 위력을 발휘 하지만 세션 타임이 적다면
멀티스레드가 좋음.  전달해야 하는 양이 적으면 그 일 완료하고 스레드가 사라지고
컨텍스트 스위칭도 줄어들음. 빠름.

웹서버가 멀티스레드로 많이 구성되어 있음.
클라이언트가 서버에 웹요청을 하면 어떤 페이지 달라 요청하면 페이지 주고서 끊음.
즉 세션이 짧고 요청도 명료하고 그에 따른 응답도 한번에 이뤄짐.

기준을 둔다면 무조건 IOCP를 선호하지말고 

멀티스레드로 서버를 구현하는게 의외로 편함. 원하는걸 논리적으로 표현하기엔

IOCP서버의 틀에 맞춰서 서비스를 하게끔 서버를 완성 시키는게 생각보다는 어려움.

코드 구현은 쓰레드 모델이 편리함. (멀티스레드는 동기화를 해줘야 하지만)

하나의 모델만 강조하는건 좋지 않음. IOCP가 아주 좋은 평을 많이 들음.

세션이 길면 IOCP가 최고지만 아닌경우에는 다른(멀티스레드)도 이슈가 될 수 있음.

=====================================================

하나의 쓰레드로 에코서버를 구현을 해야함.

오버랩드 IO모델로 

while(1)
{
	accept->read->CP(컴플리션 루틴READ에 대한)->리드 컴플리션 루틴 안에선 라이트
              -> 라이트도 오버랩드 io모델로함.-> 라이트에 대한 컴플리션 루틴 구성 -> 라이트가 끝났으면 리드 다시
              -> 이후 리드와 라이트 왔다 갔다 함. 
              (리드 라이트가 번갈아 가는 흐름에선 쓰레드가 할 일이 많이 없음.)
              (컴플리션 루틴이 실행될때마다만 쓰레드가 관여)
              (성능으로 보면 효율적 서버가 복잡할 수록 좋아보이지만 그렇지 않음.)
              (단순한게 효율이 좋음)
              (리드 라이트 함수는 하나인데 서비스 해야 하는 소켓은 여러개. 어떻게)
              (다수의 클라에 서비스를?)
              (컴플리션 루틴이 실행될려면 알렛터블 웨잇 상태로 가야함.)
              (그렇다는건 저 상태로 넣기 위한 함수 실행 필요)
              (Sleepex 함수 같은것 와일문 내에서)
              (엑셉트 실행 클라가 요청 없으면 엑셉트가 블로킹 상태)
              (그럼 슬립 EX함수 호출 불가. 실시간으로 리드 라이트 해야 하는데)
              (주기적으로 알렛터블 웨잇 상태가 되야함.  그럴려면 엑셉트 함수도)
              (리스닝 소켓을 넌블로킹 모드로 생성을 해야함 블로킹 되면 서버로서 동작 하는 상태라 보긴 좀..)
                           
}

넌 블로킹 모드로 소켓 바꾸는 법
SOCKET hLisnSock;
int mode =1;
hLisnSOck=WSASocket(PF_INET,SOCK_STREAM,0,NULL,0,WSA_FLAG_OVERLAPPED);;
ioctlsocket(hLisnSock,FIONBIO,&mode) // 입출력모드(FIONBIO)를 변수 mode에
                                                           저장된 모드로 바꿔라!

클라이언트의 연결요청이 존재하지 않는 상태에서 accept함수가 호출되면
INVALID_SOCKET이 곧바로 반환된다. 그리고 이어서 WSAGetLastError함수를 호출하면
WSAEWOULDBLOOK가 반환됨.

accept함수 호출을 통해서 새로 생성되는 소켓 역시 넌 블로킹 속성 지님.


TCP는 데이터의 경계가 없기 때문에 데이터의 일부만 왔는데
컴플리션 루틴이 실행 될 확률이 매우 높음.

일부만 들어와서 리드 CR에서 일부만 라이트를 함. 그럼 클라이언트는
일부만 리드 하게됨. 한번에 라이트 되고 한번에 리드 될거라는 가정이 있는
클라이언트를 가지고 리드 라이트를 하면 라이트는 많이 했는데
리드는 조금만 될 수 있음.  

컴플리션 루틴은 다 읽혀졌다고 가정을 하면 안됨.
클라이언트는 카운트를 해야함. 한번의 컴플리션 루틴의 반복으로 
리드 라이트를 통해 다 전송 될 수 있지만 결과적으로 전송이 다 됬지만
몇번의 컴플리션 루틴이 왔다 갔다 했는지 알 수 없음.

그래서 클라는 데이터를 샌드 하면 몇바이트 샌드 했는지 확인해서
내가 그 샌드 만큼 읽어들였는지 반복적으로 리시브 함수 호출 해야함.
정석적인 리시브 방법임 (TCP/IP의) 

오버랩드 모델로 IO할떄는 문제가 생길 수 있으니 정석적으로 구현 해야함.

내가 라이트 한거 다 받는다는것은 클라이언트에서 카운트 해야함.
서버쪽에서 보장 하는게 아님. 클라에선 내가 보낸걸 다 받겠다 
라고 하면 다 받을때까지 recv함수를 호출 해야함.(TCP의 관점임.)


오버랩드 IO 모델의 문제점
넌 블로킹 모드의 엑셉트 함수와 알렛터블 웨잇 상태로의 진입을 위한
SleepEx 함수가 번갈아 가며 반복 호출 되는 것은 성능에 영향을 미칠 수 있다!


해결책
accept 함수의 호출은 main 쓰레드(main 함수 내에서)가 처리 하도록하고 
별도의 쓰레드 추가로 하나 생성해서 클라와의 입출력을 담당하게 한다.

엑셉트 담당 쓰레드 만들고 IO만 담당하는 쓰레드를 따로 만듬.
우리가 앞에서 봤던건 하나의 쓰레드가 다 했는데 IOCP는 이렇게 나누는것임.

IOCP의 핵심은 별도로 IO를 담당하는 쓰레드를 두는것임.

======================================================

IOCP 오브젝트 생성 (소켓이 등록되는 오브젝트임)

소켓1과 소켓2가 있으면 소켓 둘을 IOCP오브젝트에 등록.

그럼 이 소켓을 대상으로 입력이나 출력을함.

입력이나 출력을 진행함. 입력이나 출력이 완료 되면 완료된 정보가

IOCP오브젝트에 등록이 됨. 그리고 그 정보를 확인 할 수 있음.

입력뒤에 할 일과 출력 뒤에 할 일이 있음. 완료가 됬다는걸 인지 해야하는데

소켓을 대상으로 확인하는게 아닌 IOCP오브젝트를 통해 확인함.(함수 호출을 통해)

함수의 반환 결과로 어떤 소켓의 입력이나 출력이 완료 됬다고 결과를 얻게 되는것.

1. 오브젝트 생성

2. 소켓 등록 (연결)

3. 입출력의 완료 정보가 IOCP 오브젝트에 자동 저장

4. 등록된 정보를 확인하고 입력이나 출력 후에 일들을 진행 할 수 있음.
(확인 후 입출력 후 확인 하는 것)

입출력이 완료 된 후의 일을 진행하는 쓰레드의 수를 우리가 정할 수 있음.

사용하는 시스템의 코어가 하나면 하나의 쓰레드로 이 일들을 처리 할 수 있다는 것.

IO를 처리하는 쓰레드 그 후의 일을 처리 하는 쓰레드로 나뉘는것이 IOCP의 핵심.


1. 연결요청 수락(소켓)  

2. 소켓을 IOCP오브젝트와 연결 (연결만 시켜 놓으면 IO가 진행되고 그 정보가 등록됨.)

3. (여기부터 별도의 쓰레드)  쓰레드가 하나 할당되어 IOCP에 완료 된게 있냐 물어봄.
   완료 된게 있으면 정보를 주고 그 쓰레드는 IO 이후에 해야 할 일들을 처리함.

기본적 IOCP의 틀은 간단.  하지만 여기에 기능을 넣을때가 문제임.


IOCP에서는 완료된 IO의 정보가 컴플리션 오브젝트라는 커널 오브젝트에 등록됨.
그런데 이를 위해서는 다음의 요구를 별도로 진행 해야야함.

"이 소켓을 기반으로 진행되는 IO의 완료 상황은 저 CP오브젝트에 등록해주세요"

IOCP의 기본 조건은

-completion Port 오브젝트의 생성
-completion port 오브젝트와 IO의 완료를 등록한 소켓과의 연결


HANDLE CreateIoCompletionPort(HANDLE FileHandle,HANDLE ExistingCompletionPort,
                                              Ulong_PTR CompletionKey,DWORD NumberOfConcurrentThreads)
이 함수는 CP오브젝트 생성하고 연결하는 기능을 제공함.
(2가지)
-  CP 오브젝트 생성시에는 INVALID_HANDLE_VALUE 전달
-  CP 오브젝트 생성시엔 NULL 전달
-  CP 오브젝트 생성시엔 0전달 
- CP오브젝트에 할당되어 IO의 처리를 담당할 쓰레드의 숫자를 지정하는것
  예를 들어 2가 전달되면 CP오브젝트에 할당되어 동시 실행 가능한 쓰레드 수가 
  2로 제한됨.  이 인자에 0이 전달되면 시스템의 CPU 개수가 동시에 실행 가능한
  쓰레드의 최대 수 로 지정됨

한 프로세스의 코어의 수 만큼 할당 하는게 보편적임.

Core <-> process (프로세스 내에 코어가 여러개 존재 할 수 있음.)

요즘은 하나의 프로세스 내에 연산에 필요한 코어가 여러개 들어 있음.

기본적으로 하나의 프로세스안에 할당된 코어의 수 만큼 할당하는게 보편적.


CP 오브젝트를 생성할때

Handle hCpObject

hCpObject = CreateIoCompletionPort(INVALID_HANDLE_BALUE,NULL,0,2)
                   (맨뒤의 2는 CP오브젝트에 할당되어 IO의 처리를 담당할 쓰레드의 
                     수를 최대 2개로 제한)


연결할때 (두 번째 기능)

HANDLE CreateIoCompletionPort(HANDLE FileHandle,HANDLE ExistingCompletionPort,
                                              Ulong_PTR CompletionKey,DWORD NumberOfConcurrentThreads)

-  CP 오브젝트에 연결할 소켓의 핸들 전달
-  소켓과 연결할 CP 오브젝트의 핸들 전달
-  완료된 IO 관련 정보의 전달을 위한 매개 변수. (이것이 소켓의 정보를 담고 있는 변수임.)
-  어떠한 값을 전달 하던 이 함수의 두번째 매개변수가 NULL이 아니면 다 무시됨.

HANDLE hCpObject;
SOCKET hSock;

CreateIoCompletionPort((HANDLE)hSock,hCpObject,(DWORD)ioInfo,0)
(hSock를 대상으로 진행된 IO가 완료시 해당 정보가 hCpObject에 해당하는 CP오브젝트에 등록됨.)

두번쨰 인자로 인해 IO가 완료 됬는지 추출이 가능 한것.

BOOL GetQueuedCompletionsStatus(HANDLE CompletionPort,LPWORD lpNumverOfbyte,
                                                   PULONG_PTR lpCOmpletionkey, LPOVERLAPPED* lpOverlapped,
                                                    DWORD dwMillisecods)

이 함수를 통해서 CreateCompletionPort 함수 호출시 전달된 정보와 
WSA Send,WSARecv 함수 호출시 전달된 정보를 얻게 된다. 그리고 이 정보를 통해서
클라이언트에게 서비스를 제공하게 된다. (CP오브젝트로 입출력이 완료된걸 뽑아 내는것)


성공시 TRUE 실패시 FALSE 반환

- 완료된 IO정보가 등록되어 있는 CP오브젝트 핸들 전달
- 입출력 과정에서 데이터 크기 정보를 저장할 변수의 주소 값 전달
- CreateCompletionPort 함수의 세번째 인자로 전달된 값의 저장을 위한 변수의
   주소 값 전달
-  WSASend WSARecv 함수 호출시 전달하는 OVERLAPPED구조체 변수의 주소 값이
   저장 될 변수의 주소 값 전달
- 타임아웃 정보 전달 여기서 지정한 시간이 완료 되면 FALSE를 반환하면서 함수를 
   빠져 나가며 INFINITE를 전달하면 완료된 CP오브젝트에 등록될때까지 블로킹 상태에
   놓이게 됨.


위 함수의 반환 결과를 통해서 두가지 정보를 얻어야 함.
-> 입출력이 발생한 소켓의 핸들 정보
-> 입출력과 관련된 데이터의 송수신 버퍼의 정보

CP오브젝트 생성 -> 오브젝트와 소켓을 연결-> 

CreateIoCompletionPort((HANDLE)hSock,hCpObject,(DWORD)ioInfo,0) 

여기서 세번째 인자에는 소켓의 정보가 담겨 있고 이것을 겟큐컴플리트스테이터스 
의 3번째 인자로 전달함

그리고 WSARecv의 인자 값인 overlappe 구조체 변수를를 또 4번쨰 인자로 전달함.
(그 운영체제가 4개 쓰고 WSAEvent 들어 있는거 이벤트 오브젝트 핸들 값 있는)

이 함수의 경우에는 전송된 바이트의 수를 둘쨰 인자로 반환되고 
IO가 완료가 됬다는걸 친절하게 설명은 안주어짐
(예를 들면 어떤 소켓의 입력이 완료가 됬다.)

CP오브젝트로부터 IO완료된 정보를 얻겠다.

어느 소켓이 완료 했다 몇바이트 전송이 완료 됬다는걸 반환 하도록

정의가 되어 있으면 좋은데 그렇게 정의가 되어 있지 않음.

대신에  나는 너가 원하는 정보를 켓큐브컴플리션의 세번쨰 인자로 

반환해주겠다는 의미.  (소켓)  전달할 정보의 폭을 우리 보고 정하란 의미

IO가 완료 됬을떄 어떤 Recv가 완료 됬는지 알려면

어떤 Recv가 완료됬는지 전달하진 않을테니 너가 Recv를 호출할떄 전달한

4번쨰 인자 그걸 그대로 돌려주겠다. 라는 의미

 
CreateIoCompletionPort의 3번째 인자는 우리가 정의 하면 됨.
얻고 싶은 정보를. 

즉 GetQueuedCompletionsStatus 함수로 어느 소켓이 입출력이 완료된 소켓인가를
알고 싶을땐 3번쨰 인자로 CreateIoCompletionPort의 3번째 인자로 넣은 변수의 
주소 값을 넣어주면 됨. 그럼 소켓정보 얻을 수 있고 그걸로 IO진행

Recv 의 경우는 버퍼 정보임. WSARecv의 경우엔 버퍼에 대한 정보가 4번쨰 인자인데
GetQueuedCompletionsStatus의 4번째 전달 값으로 WSARecv의 4번째 인자를 요구하고
입출력이 완료된 WSARecv의 버퍼 정보를 우리가 정의한 구조체에 담아줌.

구조체를 어떻게 전달 하느냐에 따라 좀 더 다양한 정보를 얻을 수 있음.
예제는 그저 예제일뿐임.

예제에서는 입력이 완료된건지 출력이 완료 된건지 확인 하는걸 추가함. 
이걸 4번째 인자 구조체로 확인 가능 그 정보를 알 수 있음.

CP오브젝트에서 IO를 담당할 오브젝트의 수를 지정함.(4번째 인자로)
여기서 자동으로 생성되는건 아님.


가장 많이 한 질문.

그럼 io에 어떻게 쓰레드를 할당 해야 하나요 ?

혹시 쓰레드가 자동으로 생성되어서 io를 처리하게 되나요 ?

CP오브젝트에서 IO를 담당할 오브젝트의 수를 지정함.(4번째 인자로)
여기서 쓰레드가 자동으로 생성되는건 아님. 
쓰레드가 처리 할 일을 우리가 직접 쓰레드의 메인함수를
정의해서 직접 정의 해야함. 쓰레드는 우리가 생성해서 
메인함수를 실행되게 해야함.  별도의 생성과정이 있는게 아니고 
쓰레드를 하나 만들면 GetQueuedCompletionsStatus  이 함수를 실행하는게
io담당 쓰레드가 할 첫번쨰 일 함수로 어떤게 io가 완료가 되었는지 알았고 
그 이후의 일을 담당함. 쓰레드의 메인함수에선 GetQueuedCompletionsStatus  
를 호출하고 이걸로 입출력이 됬는지 안됬는지 확인하고 그 이후 일을 담당하는것임.

쓰레드는 그럼 어떻게 할당 하나요가 아님. 할당하는 코드는 없음.

쓰레드가 GetQueuedCompletionsStatus 를 호출하는것 자체로 할당 한다는 의미 

우리가 CreateIoCompletionPort의 마지막 인자로 할당된 숫자가 

GetQueuedCompletionsStatus을 호출 할 수 있는 쓰레드의 숫자임.

예를 들면 2를 전달했다면 GetQueuedCompletionsStatus  를 호출 할 수 있는

쓰레드가 2개임. 그 말은 결국 두개의 쓰레드만이 컴플리션포트와 일 할 수 있다는 것.

쓰레드를 컴플리션 포트에 할당한다는 말을 하는데 cp오브젝트와 소켓의 할당처럼
함수 호출을 통한 명확한 관계가 아니고 GetQueuedCompletionsStatus를 호출 할 수 있다는게
2개 라는 뜻임. 


GetQueuedCompletionsStatus 함수를 호출하는 쓰레드는 io를 처리하는 쓰레드임.
io처리에 필요한 결과를 GetQueuedCompletionsStatus  에서 반환 하기 때문
그리고 이러한 역할을 담당하는 쓰레드는 프로그래머 직접 생성 해야함.

구조체 멤버의 첫번째 주소 값은 구조체의 주소 값과 동일.



tydef struct 
{
    OVERLAPPED overlapped; //WSARecv나 WSAsend를 호출할떄 오버랩드 구조체를 넣어줘야함.
    // 구조체 멤버의 첫번째 주소 값은 구조체의 주소 값과 동일. 오버랩드 구조체의
       주소값을 넘긴다는건 우리가 정의한 구조체 변수 자체의 주소 값을 넘기는것임.
    WSABUF wsaBuf;
    int reMode; // 리드인지 라이트인지...
}  PER_IO_DATA,*LPPER_IO_DATA

GetSystemInfo 함수 호출로 코어의 수를 얻어 낼 수 있음.

GetSystemInfo(&sysInfo); 이렇게 호출하면
sysInfo 구조체의 dwNumverofProcess 에 코어의 값이 저장됨.






