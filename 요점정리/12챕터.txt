TCP 프로그래밍은 두갈래로 나뉜다.

SELECT 와 MP(멀티프로세스)

멀티 프로세스는 멀티 스레드 방식

셀렉트는 
이폴과 IOCP
(리눅스) (윈도우)

멀티프로세스 서버는 클라이언트 하나당 프로세스 하나를 생성하는건 비효율 성능저하임.
프로세스간 흐름을 고려해야 하기에 구현하기 어려움.
프로세스간 통신이 필요한 상화에선 서버의 구현이 더 복잡

멀티프로세스 서버의 대안
하나의 프로세스가 다수의 클라이언트에게 서비스 할 수 있도록 한다.
이를 위해서는 하나의 프로세스가 여러개의 소켓을 핸들링 할 수 있는 방법이 존재 해야 한다.
이것이 IO멀티플렉싱임.


하나의 리소스를 둘 이상의 영역에서 공유하는게 멀티 플렉싱.
왜 문제가 안생기는가. 두 영역의 주파수가 달라서.  주파수로 구분해서 들으면 됨.(컵의 경우는)

멀티프로세스 서버는 프로세스와 클라이언트가 1:1 이었음.
멀티 플렉싱은 프로세스와 클라이언트가 1:M임.

하나의 프로세스가 여러개의 소켓을 묶어서 관리 하기 때문.


=============================================================================================


SELECT 함수의 목적

프로세스 하나로 여러 클라이언트에 서비스를 하는것.
그럴려면 여러 클라이언트에 파일디스크립터를 하나의 프로세스가 관리 해야함.

멀티 프로세스의 경운 1:1이지고 1:!이 서비스의 퀄이 좋아보임.

하나의 프로세스로 여러개에 서비스를 하면 편하겠지만 질이 떨어질까봐 걱정됨.

허나 프로세스는 제법 부담스러운 작업이라, 하나로 하는게 효율이 좋음.

온라인 게임으로 비유하면 서버하나에 1000명이 접속하면 프로세스도 1000개...
이건좀 아니다... 매우 비효율적.

실제로 서버와 클라이언트가 데이터를 주고 받는텀이 꽤 길다.

사람이 보기엔 짧지만. 바이너리관점에서 봤을때 길다.

하나의 프로세스가 모든 요청을 처리 할만큼 텀이 남음.

그렇기 때문에 하나의 프로세스를 가지고 서비스 하는게 효율적이고 서버의 성능도 향상됨.

이러한 경우에 더 많은 클라이언트에 서비스를 제공 가능.  서비스 품질도 좋아짐.

멀티프로세스기반보다 셀렉트가 더 좋지 않는가 하면 대부분에 상황에 셀렉트가 더 좋지만

그렇지 않은 경우도 있음.  


서버하고 클라이언트가 있으면 서버는 리스닝 소켓을 우선 생성하고 

클라가 연결요청을 하면 클라이언트 소켓 총 두개 가지게 됨. 소켓이란건 파일디스크립터임.

또 다른 클라가 요청하면 또 다른 클라 소켓이 필요함. 소켓이 여러개 라는건 파일디스크립터가

여러개 라는거고 어느 소켓이 요청 하는지 파일디스크립터를 묶어서 관찰 할 필요가 있음.

그것을 묶어서 관찰 할 수 있게 하는게  fd_set 자료형임. 리스닝 소켓의 파일디스크립터가 5라고 하면

fd_set의 5번이 1로 바꿔야함.  클라 소켓이 요청하면 거기의 파일디스크립터가 6이라면 거기도 1로 바뀜.

서버 입장에서 리드 할려면 어느 소켓에서 데이터를 읽어야 하는지 알아야함.  

그걸 알 수 있게 하는게 셀렉트 함수임. (내가 소켓에 리드 라이트를 할 수 있는지... 예외가 발생한 파일 디스크립터가 있는지)


5번 디스크립터에 수신된 데이터가 있는지 그게 6번 7번인지 물어볼 수 있음.

변화가 있는 파일 디스크립터 값을 1로 바꿔줌. 나머진 전부 0으로 바꿔버림.

이것은 문제임. 나머지 소켓의 정보가 지워지기 때문.

그래서 셀렉트 함수를 호출하기전에 원본을 카피 해야함.

셀렉트 함수는 어느곳이 1인지 위치를 하나 하나 찾아가서 확인 해야함. 

찾아서 만약 파일디스크립터 7번이 1이면 거기서 부터 리드하고 다시 라이트를 해주면 됨.

그리고 복사해둔 원본을 찾아가서 다시 셀렉트를 호출함.  이것이 바로 셀렉트 함수의 모델임.

클라이언트의 연결 요청도 데이터라서 리스닝 소켓도 담기는것 이게 무슨 의미냐면

리드할 데이터가 리스닝 소켓 이면 아 연결요청이구나 하고 이에 따른 코드를 작성 해야함.

요약하면 여러 파일 디스크립터를 모아놓고 이것을 셀렉트 함수로  관찰하고 셀렉트 함수로 변화된 즉 읽어들인 데이터가 있는 파일디스크립터를 가지고 서비스를 제공함.

셀렉트 함수의 3가지 틀

수신할 데이터를 지니고 있는 소켓이 존재하는가?(read, 소켓에 데이터가 있다, 즉 읽어야 하는것)

블로킹 되지 않고 데이터의 전송이 가능한 소켓은 무엇인가?(write, 블로킹 되지 않고 다 보낼 수 있는가)

예외상황이 발생한 소켓은 무엇인가? (예외가 발생한 소켓의 파일디스크립터를 얻음)

셀렉트 함수가 호출되고 나면 타임아웃 정보가 바뀜. 타임아웃이 5초면 3초가 지나서 데이터의 변화가 발생하여 

셀렉트 함수가 호출이 되면 남은 2초가 남음. 규칙적으로 계속 호출할려면 셀렉트 함수 앞에서 재정의 해야함.




파일디스크립터를 모아 놓는것,
검사범위를 지정하는것
블로킹이 발생하지 않게 타임아웃을 지정하는것 



  





 
