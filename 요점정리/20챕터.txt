윈도우 운영체제의 연산방식에는 유저모드와 커널 모드가 있다.

보통 32비트 시스템은 운영체제와 하드웨어가 둘다 32비트임.

반대로 64비트의 경우는 운영체제와 하드웨어가 둘다 64비트 라는것.

하지만 만약 운영체제가 32비트 하드웨어가 64비트면  이건 32비트 시스템임.

하드웨어가 64비트일지라도 이걸 사용하는 운영체제가 32비트 까지 밖에 쓸 줄 모름.

결론은 대부분 n비트 라는건 대부분 운영체제 쪽을 따라감.

프로세스가 할당 받는 메모리가 4기가라 가정.

OS와 운영 어플리케이션만 있는 경우만 가지고 이야기를 해보면

프로세스에 4기가를 배정해주는데 모든 프로세스에 각각 4기가를 배정은 못함.
(할 수 있다면 다른 메모리 기법이 있는것임.)

32비트는 할당 할 수 있는 메모리 크기가 4기가임. 할당 할 수 있는 주소 갯수가

2의 32승개라서. 각 메모리마다 1바이트씩 하다보면 4기가임...

이 4기가를 유저 혼자 못쓰고 운영체제랑 같이 써야함.

프로세스가 4기가를 먹었다는건 운영체제랑 같이 쓴다는것.

OS가 2기가 나눠서 쓰고 어플리케이션이 2기가 나눠 쓰고 있다 쳐보면

운영체제는 우리쪽 메모리에 접근 할 수 있지만 우리는 운영체제가 관리하는

메모리에 접근이 불가능함.  만약 접근 할 수 있다면 운영체제가 중요한 정보를

저장해둔 주소공간에 200을 집어 넣으면 시스템에 치명적 손상을 할 수 있음.

응용 어플리케이션이  실행 될때에는 프로세스가 유저모드를 기반으로 동작

유저 모드는 접근 할 수 있는 메모리를 제한을 하는 곳.
(OS 영역의  메모리 영역은 접근 불가)

접근 불가능한 영역에 값을 저장할려고 한다면 , 프로세스가 실행이 안될 것.

다음은 OS가 동작 할때.

APP가 쓰레드 생성을 요청하면 운영체제에서 만듬.

같이 만들어지는 리소스와 커널 오브젝트는 운영체제의 메모리 공간에 할당됨.

그러면 이 메모리 공간에 접근이 막히면 안됨. 이러한 운영체제가 동작할때는

이런 제한을 풀어버리는 커널 모드로 동작함.

1. 어플에서 쓰레드 생성 요청
(이것은 프로세스가 요청하는것.)

2. 그 요청을 받기 위해 운영체제 동작.

3. 운영체제 메모리를 써야 하기 때문에 커널 레벨에서 수행 해야함.
(운영체제에 할당된 메모리 공간으로)

정리
1. 응용 프로그램이 실행중일떄 커널 오브젝트 관련된 경우에는 커널 모드로 전환이 됨.
2. 작성한 코드의 실행은 유저모드로 전환됨.
3. 매우 빈번하게 유저모드와 커널모드를 왔다 갔다 하면서 실행됨.

유저모드 : 응용 프로그램이 실행되는 기본모드. 응용 APP에게 할당 된 것 말곤 접근 불가
          ex)  APP에서 H/W에 접근할려면 OS의 도움을 받음. 
                이러한 요청을 함수호출로 함. 이 순간 OS는 커널모드로 바뀌어 
                하드웨어에 접근을 해서 다시 실행결과를 알려줄떄 유저모드로 바뀜.

커널모드 : 운영체제가 실행될때의 모드로 메모리뿐 아니라 하드웨어 접근에도 제한이 따르지 않음.

동기화 기법


유저모드 동기화와 커널모드 동기화 기법이 있음.

유저모드 동기화 : 커널의 도움 없이 순수하게 APP영역에서 동기화를 하는 것.
ㄴ 전환이 이뤄지지 않으니 가볍고 빠름.

커널모드 동기화 : 동기화의 기능을 커널이 제공함.(커널모드로 전환이 됨.)
ㄴ 커널에 의해 제공 되는 것이니 다양한 기능 제공
ㄴ 한가지 예로 데드락에 걸리지 않도록 타임아웃 지정 가능.

★ 데드락 : 임계 영역에 진입을 대기중인 블로킹 상태에 놓여 있는 쓰레드가 이를 빠져 나오지 못하는 상황을 의미함.
               뮤텍스를 예로 든다면 임계영역에 들어간 쓰레드가 빠져나올떄 unlock함수를 호출 하지 않아도 데드락임.
                이는 매우 단순한 경우고 원인의 파악조차 쉽지 않을정도로 애매한 상황에서 데드락 상황이 발생함.

CRITICAL_SECTION 동기화
리눅스으 뮤텍스와 매우 유사.

크리티컬 세션 오브젝트(뮤텍스 설명떄의 열쇠)
는 커널 오브젝트가 아니라가 아니고 유저모드에서 만 동작
복잡한 동기화가 필요하지 않을떄 사용 되는 기법.

========================================================================


커널 동기화 방법

뮤텍스, 세마포어, 이벤트 세 종류가 있음.

뮤나 세는 앞에서 했었음. 비슷함. 이벤트도 뮤나 세가 제공하지 않는것을

제공하기 때문에 공부가 필요.

뮤텍스는 열쇠임.

HANDLE CreateMutex(LPSECURITY_ATTRIBUTES lpMutexAttribytes,
                               Bool bInitialOwner,LPCTSTR lpName)

- 보안관련 특성 정보의 전달 디폴트 보안설정을 위해 NULL전달
- TRUE 전달시 생성되는 뮤텍스 오브젝트는 이 함수를 호출한 쓰레드의
  소유가 되면서 논 시그널드 상태가 된다. 반면 FALSE 전달시 생성되는
  뮤텍스 오브젝트는 소유자가 존재하지 않으며 시그널드 상태로 생성된다.
- Mutex 오브젝트에 이름을 부여할떄 사용됨 NULL을 전달하면 이름 없는
  Mutex 오브젝트가 생성된다.

윈도우의 뮤텍스 생성 함수는 반환형이 HANDLE형임.
반환형이 핸들이라는건 커널 오브젝트가 생성된다는 의미.
주의해서 봐야 할 건 두번째 인자임.

임계영역에 접근할려면 열쇠가 필요
열쇠를 획득하기 위해선 소유가 가능 해야함. 그러기 위해선
뮤텍스 커널 오브젝트 함수가 시그널드인지 확인 해야함.
그 함수가 waitforsingleObject 함수임.

★ 중요
뮤텍스는 오토리셋커널오브젝트임 (자동으로 논시그널드로 바뀌는거)
웨잇포 싱글오브젝트 함수 빠져나오면서 논시그널드로 스위칭.
웨잇포 싱글 오브젝트 호출된 순간에는 시그널드 상태 그러면서 임계영역 
진입 하지만 반환되면서 논 시그널드로 스위칭. 그러면서 임계영역 진입 막음
(논 시그널드 라는건 열쇠를 얻을 수 없는 거니까)

임계영역 빠져 나갈때는 ReleasMutex 함수임. 열쇠를 얻으면
시그널드 상태가 됨. 그건 바로 열쇠를 얻을 수 있는 상태 라는 것.

ReleasMutex(HANDLE hmutex)
성공시 트루 실패시 펄스 반환
- 반납할, 다시 말해서 소유를 해제할 Mutex 오브젝트 핸들 전달

세마포어

HANDLE CreateSemaphore(LPSECURITY_ATTRIBUTES lpSemaphoreAttribytes,
                                      LonglInitialCount,LONG IMaximumCount,LPCTSTR lpName)
-보안관련 정보 전달 디폴트로 설정은 NULL
-세마포어 초기 값
-세마포어 최대 값
- 이름 지정 NULL 전달하면 이름 없는 세마포어 오브젝트 생성.




두번째 인자와 세번째 인자가 중요. 3번째 인자의 경우는 임계영역에 
몇개의 쓰레드가 들어 갈 수 있는가 결정하는 숫자.

두번째 인자는 세마포어 생성 후 초기의 카운트 값을 지정 하는 것.
(3번째 인자의 값보다 늘 같거나 작아야함. 3번쨰 인자가 맥시멈 값이니까)

바이너리 세마포어
뮤텍스와 유사한 성격으로 사용함.  세번쨰 전달 인자로 1을 둠. 이 것은
두번쨰 인자 값이 0 또는 1이라는 의미인데 임계 영역에 하나의 쓰레드만
들어 갈 수 있다는 것. 뮤텍스처럼.

세마포어 오브젝트가 값이 0인 경우 논 시그널드 상태.
0보다 큰 경우에 시그널드 상태가 됨.

이 말은 0보다 큰 경우에 열쇠의 갯수를 말 하는 것.
예를들어 카운트가 3이면 3->2->1->0 으로 변화 가능.
각각 다른 쓰레드가 3->2로 또 다른 쓰레드가 2->1로 또 다른 쓰레드가
또 1->0으로 변화 시킬 수 있다는 것. 총 3개 쓰레드가 세마포어 값을 줄일 수 있음.

뭘로 줄이냐면 웨잇포싱글오브젝트 류 함수들임.

현재 세마포어 값이 3임. 웨잇포싱글오브젝트 함수 호출.

숫자 3 시그널드 상태 바로 임계영역으로 들어가고 숫자 2로 줄음.

이 과정 총 3회 반복 가능. 0이되면 논시그널드 상태가 되서 웨잇포싱글오브젝트
함수가 반환 불가 상태됨(임계영역진입불가)

ReleaseSemaphore(HANDLE hSemaphore,LONG lReleaseCount,
                          LPLONG lpPreviousCount)
성공시 트루 실패시 펄스 반환
- 반납할 세마포어 핸들
- 반납될떄 증가할 세마포어의 값(임계영역 진입할때 값이 2씩 줄지 않고 1씩
                                              줄어드니 보통 1로 설정)
- 이전 세마포어 카운트 값을 얻을 수 있음. 불필요 하면 NULL 전달

반납할 세마포어 핸들,반납은 세마포어의 값 증가를 의미하는데 증가 되는 값 
크기 전달 (일반적으로 증가 하는 값),

둘 이상의 쓰레드가 호출해서 임계 영역에 들어 갈 수 있는 특징이 있는게 세마포어


Event 오브젝트 
뮤텍스,  오토리셋 이었음.
세마포어 세마포어 값이 감소 하면서 시그널드가 논시그널드가 되어버림
             (오토리셋)
이벤트  오토리셋으로도 생성 할 수 있고 매뉴얼 리셋으로도 가능.

HANDLE CreateEvent(LPSECURITY_ATTRIBUTES lpEventAttributes, Bool bManualReset,
                              BOOL bInitialState,LPCTSTR lpName)
성공시 event 오브젝트 핸들 전달 실패시 NULL 반환

- 보안관련 정보 전달 보통 NULL
- TRUE 전달시 매뉴얼 리셋 모드 이벤트 FALSE  전달시 오토 리셋 모드 생성
- 트루 전달시 시그널드 상태의 이벤트 오브젝트 펄스 전달시  논시그널드 이벤트 
  오브젝트 생성
- 이름부여 NULL 전달시 이름 없.

Event 오브젝트는 매뉴얼 리셋모드로 생성 하는게 장점임.
매뉴얼로 생성하면 웨잇포오브젝트 함수를 써서 반환하더라도 
시그널드 상태가 논 시그널드로 안바뀌니 누군가 명시적으로 NS
상태로 바꾸지 않으면 계속 진입이 된다는 것.

이것이 유용한 상황이 있음.

임계영역에는 값을 변경하는 쓰레드는 하나만 들어가야 하지만
그냥 참조만 하는 쓰레드는 여러개가 들어가도 괜찮음.
매뉴얼은 시그널드 상태에서 자동으로 안바뀌니 여러개가 들어 갈 수 있음.

어떠한 조건이 만족되었을때 둘 이상의 쓰레드 진입을 허용한다 그런 의미.

BOOL ResetEvent(핸들값)  논시그널드로 바꿈
BOOL setEvent (핸들값)  시그널드로 바꿈.

예제의 경우는 쓰레드1은 A의 갯수 세는것. 쓰레드2는 A를 제외한
나머지 문자의 갯수 세는것. 변경이 아니고 검색하고 참조 하는 것이니
동시 접근해도 됨.


정리

뮤텍스 : 열쇠를 두고 하나가 들어가서 빠져나와서 열쇠를 반납할때 까지
            임계 영역 진입 불가.

세마포어 : 열쇠의 갯수를 정해두고 그 수 만큼 임계영역 진입 가능.
               (동시에도..)
               
이벤트 : 문 열었다 하면 무한정 들어 갈 수 있고 닫으면 못들어 가고 하는 구조




