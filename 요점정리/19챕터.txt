리눅스 프로그래밍에서 가장 중요했던것 두개

이폴,쓰레드

쓰레드의 아래의 사항은 윈도우에서도 유지됨.
모든 쓰레드들은 힙과 데이터 영역은 공유하지만 스택은 별도임.

실행흐름을 위한 최소한의 독립 메모리가 스택이기에.

이폴의 장점
언뜻 쓰레드가 좋아보이지만, 멀티플렉싱으로 구현된 서버들이 많음.
멀티플렉싱의 대표적인게 셀렉트인데, 셀렉트의 단점을 커널레벨에서
계량한게 이폴임. 

셀렉트의 확장레벨이라 볼 수 있고 이폴의 윈도우 버전이라고 볼 수 있는
IOCP가 있음.



커널 오브젝트의 개념

윈도우가 하는 일
- 다수의 프로세스를 관리함(그안의 쓰레드까지)
- 파일도 관리함.
- 기타등등(시스템 리소스)를 관리함.

예를들어 물건을 파는 회사에서 물건을 관리를 해야 한다 치자.

그럼 우리는 먼저 물건에 대한 관리내역서를 작성함.

이렇듯 운영체제도 프로세스를 하나 만들면 그게 관리 대상이라

프로세스에 대한 관리 내역서를 만듬. 쓰레드도 각 쓰레드에 관한

각각의 내역서 파일도 파일에 대한 내역서를 작성함. 

프로세스인지 파일인지 부터 시작해서 각종 정보가 저장되어 있음.

이런 정보가 저장되어 있는 메모리를 커널 오브젝트라 함.

여러가지 정보가 담길 수 있는 프로세스 정보를 담을 수 있는

구조체를 선언하고 파일 정보를 담을 수 있는 구조체를 선언하는것과 

마찬가지임.  프로세스의 모든 실시간 상황은 커널 오브젝트를 통해 

알아 볼 수 있고 그 커널 오브젝트는 그 리소스를 대표하는 의미임.

커널 오브젝트를 참조 한다는것은 해당 프로세스에 대한 정보를 유지 하고 있단 의미

쓰레드 같은 경우는 쓰레드의 우선순위가 담겨있는데 이런게 커널 오브젝트에 담겨 있고

파일도 읽기전용인지 쓰기전용인지도 담겨 있음. 이런것들은 리소스에 따라 달라짐.

흐름.
프로그램 영역에서 쓰레드를 전달하라고 운영체제로 전달
운영체제는 쓰레드를 생성 쓰레드를 지칭 할 수 있는게 필요함.(아마ID인듯)
운영체제는 쓰레드를 만들떄 커널 오브젝트를 같이 만듬. 커널 오브젝트에 해당 쓰레드 정보 채움.
커널오브젝트의 정보는 쓰레드와 연결되어 실시간 갱신.
커널 오브젝트는 쓰레드를 대표하는 어떤 대상. 이 커널 오브젝트를 지칭 할 수 있는
핸들값을 넘겨줌. 이 10이라는 핸들 값은 운영체제와 우리와의 약속임.
이 10은 쓰레드 A를 지칭한다 같은. A쓰레드에 정보를 변화 시킬려면 
10이라는  핸들 값을 호출하면서 쓰레드의 변경 사항을 운영체제로 전달하면 
운영체제는 10의 핸들 값을 가진 커널 오브젝트가 그 변경사항을 전달하고 커널 오브젝트는 쓰레드에
변경사항을 적용한다 보면됨.

핸들은 커널오브젝트를 지칭하고 커널 오브젝트는 리소스를 지칭 리소스의 모든 정보는
커널 오브젝트에 등록되어 있음.

대부분의 리소스(파일,프로세스,쓰레드)에 커널이 생성해주고 커널이 관리하는 모든 리소스는 커널 오브젝트가 
생성되고 그에따른 핸들이 반환됨.


정리 

운영체제가 만드는 리소스의 유형
- 프로그램의 실행과 관련된 프로세스와 쓰레드
- 입출력의 도구가 되는 소켓과 파일
  ㄴ 소켓을 생성해도 커널오브젝트가 생성됨. 커널 오브젝트를 생성하면 그걸 
      지칭하는 핸들값이 반환되고 우린 그 핸들 값을 이용해서 변경사항이 소켓에 반영
- 쓰레드간의 동기화의 도구로 사용되는 세마포어 뮤텍스
  ㄴ 세마포어 나 뮤텍스 생성해달라하면 커널 오브젝트 생성되고 핸들이 반환 그걸로 변경사항 반영.
리소스와 커널 오브젝트의 관계
- 리소스의 관리를 위해서 운영체제가 만드는 데이터 블록이 커널 오브젝트임.
- 커널 오브젝트에는 해당 리소스의 정보가 저장되어 있음.
- 리소스의 종류에 따라서 생성되는 커널 오브젝트의 형태에도 차이가 있음.

커널 오브젝트의 소유자
- 커널 오브젝트의 생성, 관리, 소멸은 운영체제가 담당함.
  ㄴ 변수 하나 선언한다고 그게 커널 오브젝트가 아님. 프로그램상에서 확인 불가 운영체제단에 생김.
- 즉 커널 오브젝트의 소유자는 운영체제임.

============================================================================

윈도우 기반의 쓰레드 생성

프로세스는 쓰레드가 담기는 상자이다.(프로세스에 종속적 한마디로 프로세스가 없다면 쓰레드도 없는)
- 운영체제 레벨에서 쓰레드를 지원한다  따라서 main함수 호출은 쓰레드에 의해서 이뤄진다.
- 쓰레드를 추가로 생성하지 않으면 하나의 프로세스내에 하나의 쓰레드가 생성되어 쓰레드에 의해서 실행된다.
- 과거 쓰레드를 운영체제 레벨에서 지원하지 않던 시절엔 프로세스가 단순히 쓰레드를 담는 상자로 묘사 되지 않닸다.
  ㄴ 커널 레벨에서 프로그램 실행의 최소 단위가 쓰레드임. (과거에는 프로세스 였음)

쓰레드 생성에 따른 프로그램의 모델
- 단일 쓰레드 모델의 프로그램
-> 추가로 쓰레드를 생성하지 않은 모델의 프로그램

- 멀티 쓰레드 모델의 프로그램
-> 프로그램내에서 추가로 쓰레드를 생성하는 모델의 프로그램.

윈도우에서의 쓰레드를 생성하는 함수 

쓰레드 ID
운영체제가 임의의 리소스를 만들면 리소스가 만들어지면 커널 오브젝트도 만들어짐.
프로세스에 이 핸들값을 전달.

프로세스 A가 핸들 값 10을 가지고 이 리소스에 접근 가능.
프로세스 A가 프로세스B에게 자신이 얻은 핸들 값을 주면 그 리소스에 접근이 불가능함.
핸들값은 프로세스에 종속적임.  그 프로세스에서만 사용 가능.  리소스는 프로세스에 종속적이지 않음.
운영체제 관할이라. 핸들값만 종속적인것 한마디로 A프로세스에서 운영체제가 리소스에 대한 핸들값 10을 주면
B프로세스에선 10으로 그 리소스에 접근 불가능 


둘 이상의 프로세스가 하나의 리소스를 지칭하고 싶다 이럴때 쓰이는게 ID임.
프로세스간에 어떤 리소스를 지칭할때 쓰는것. 


크리에이트 쓰레드 함수는 문제가 있음.
쓰레드에 안전한 함수와 불안전한 함수가 있었음.

C/C++ 함수는 멀티스레드 모델을 고려하지 않았었음.
둘 이상의 쓰레드가 동시 접근해도 문제가 일어나지 않는 별도의
라이브러리를 개발함. 둘 이상의 쓰레드가 동시 접근해도 문제 일어나지 않는
라이브러리! 

라이브러리만 고치면 형태나 구조가 좀 불안정하고 비효율적이라

쓰레드 모델도 변경 그래서 나온게  _beginthreadex 함수임. createthread함수와
전달하는 인자는 완전히 같음.

리눅스와 달리 윈도우의 쓰레드는 쓰레드 함수를 반환하면 자동으로 소멸됨.
리눅스와 달리 쓰레드의 완전한 소멸을 위해 조인이나 디태치를 할 필요가 없음.



=========================================================

커널 오브젝트의 두 가지 상태 

동기화를 쓸 수 있어야 멀티 쓰레드 프로그래밍을 한다 할 수 있음.

동기화를 이해 하기 위해선 이걸 알아야함.

쓰레드의 커널 오브젝트는 두가지 상태가 있음.

Non-signled 상태 
-> 이벤트가 발생하지 않은 상태 해당 리소스가 특정상황에 이르지 않은 상태

signaled 상태 
-> 이벤트가 발생한 상태, 해당 리소스가 특정상황에 도달한 상태 



메인 함수 입장에서 대표적으로 궁금한건 쓰레드는 실행중인지 종료중인지임.(이게 결정되있음)

대부분의 커널 오브젝트는 NS(논시그널드)상태에서 시작함.

쓰레드의 커널 오브젝트는 쓰레드가 종료되었을떄 시그널드 상태가 됨.

관심사를 두고 그 관심사 상태가 되면 시그널드가 됨. (그 관심사란 종료 인지 아닌지)

정리 

커널 오브젝트에 특정 상태(이벤트 발생)가 되었을때 시그널드 상태가 된다.
ㄴ 이벤트는 약속되어 있음. 우리가 정하는건 아님. 커널 오브젝트별로 다름.

시그널드 상태가 되면 어떤 기대하는 형태에 이르렀다.

리소스 별로 시그널드 상태가 되는 조건은 각기 다르다.

커널 오브젝트 상태 확인 함수 

DWORD waitForSingobject(HANDLE hHandle, DWOD dwMillseconds)
-> 성공시 이벤트 정보, 실패시 WAIT_FAILED 반홤

해당 핸들값에 해당하는 커널 오브젝트가 시그널드인지 묻는 함수

- hHandle : 상태 확인의 대상이 되는 커널 오브젝트의 핸들 전달
- dwMilliseconds : 1/1000초 단위로 타임 아웃 지정 INFINTE 전달시 커널 오브젝트가 
                         signaled상태가 되기전엔 반환 하지 않음.
- 반환 값 : signaled 상태로 인한 반환시 WAIT_OBJECT_0 반환, 타임아웃으로 인한 반환이면 
               WAIT_TIMEOUT 반환.

DWORD WaitForMultipleObjects
(DWOD nCount, const HANDLE* lpHandles,BOOL bwaitAll,DWOD dwmilliseconds)
-> 성공시 이벤트 정보, 실패시 WAIT_FAILED반환

- 검사할 오브젝트의 수 전달
- 핸들정보를 담고 있는 배열의 주소 값 전달
- TRUE 전달시 모든 검사대상이 signaled 상태가 되어야 반환 FALSE 전달시 하나라도
  signaled 상태가 되면 반환
- 1/1000초 단위로 타임아웃 지정 인자로 INFINTE 전달시 커널오브젝트가 
  signaled 상태가 되기전에 반환하지 않음.

함수를 빠져나오고 나서 논 시그널드 상태로 변경되는 커널 오브젝트가 있고 
그대로 시그널드가 유지 되는 커널 오브젝트가 있음.

웨잇포싱글오브젝트 함수 호출해서 함수를 빠져 나왔을때

시그널드에서 논시그널드로 돌아가는걸 오토 리셋 모드 커널 오브젝트
그냥 그대로인것은 매뉴얼 리셋 모드 커널 오브젝트 라고 함.














 
