Overlapped IO

Overlapped 중첩됬다 라는 의미임.

IO의 중첩이라는 것은 쓰레드의 관점에서 동시에 둘 이상의 데이터 전송을
중첩 시키는것을 뜻한다. 그리고 데이터의 전송을 중첩시키기 위해서는
입출력 함수가 넌 블로킹 모드로 동작 해야 한다. 그래서 연 이은 데이터의 
입력 및 출력이 가능 해진다.

소켓 하나에다가  여러번 라이트 함수를 호출을 해도 동시에 가진 못함.
그 소켓이 가진 버퍼는 하나 이기 때문. 끝나고 가고 끝나고 가고 그럼.

반대로 쓰레드 하나에 여러개의 소켓이 연결되어 있으면 각각의 소켓이
동시에 라이트가 진행 가능함. 이게 우리가 목표로 하는 오버래핑 IO임.

덧붙여 두개 이상의 소켓에 데이터를 중첩 전송해도 성능이 떨어지진 않음.
성능은 인터넷 환경에 따라 다름.  즉 중첩 시킬수록 효율이 좋다는것.
그리고 이건 보내는 데이터 양이 클 수록 더 효율적임.

3바이트 씩 3번은 의미가 적지만 100메가를 3번 보낼때는 엄청난 차이가 있음.
이걸 블로킹 모드로 하면 100메가 보내고 다음 100메가 보내고 하기 떄문에
느림. 

넌블로킹 방식의 단점은 리드가 됬는지 안됬는지 별도의 확인 과정을 
거쳐야 함.(코드레벨에서 귀찮은 작업)
반면 블로킹 방식은 반환이 곧 전송완이기 때문에 확인 안해도 됨.

성능이 10퍼 떨어져도 구현편의성이 50퍼 좋다 싶으면 구현의 편의성으로 
가는 경우도 많음.

비동기 IO와 Overlapped IO의 비교

비동기
- IO의 비동기란 넌 블로킹 모드의 IO를 뜻한다.
- IO가 비동기 방식으로 동작해야 IO를 중첩 시킬 수 있다.
- 윈도우의 Overlapped IO는 IO를 중첩 시키는 입출력 모델이다.
   
Overlapped IO
- Overlapped IO가 아니더라고 IO를 중첩 시킬 수 있다
- Overlapped IO의 포커스는 IO가 아닌 ★입출력 완료의 확인 방법에 있다

비동기 IO는 입출력의 완료를 확인하는게 껄끄러운데 
Overlapped IO는 이 입출력의 완료를 확인하는게 좀 더 체계적으로 
설계 된 것.

Overlapped IO 소켓의 생성

SOCKET WSAsocket(int af,int protocol,LPWSAPROTOCOL_INFO,GROUP g,
                            DWORD dwflags)
-> 성공시 소켓의 핸들, 실패시 INVALID_SOCKET 반환

- 프로토콜 체계 정보 전달
- 소켓의 데이터 전송방식에 대한 정보 전달
- 두 소켓 사이에 사용 되는 프로토콜 정보 전달
- 생성되는 소켓의 특성 정보를 담고 있는 WSAPROTOCOL_INFO 구조체로 
  변수의 주소 값 전달 필요 없는 경우 NULL 전달
- 함수의 확장을 위해서 예약되어 있는 매개변수 따라서 0 전달
- 소켓의 속성 정보 전달

WSASocket(PF_INET,SOCK_STREAM,0,NULL,0,WSA_FLAG_OVERLAPPED)
마지막 인자로 WSA_FLAG_OVERLAPPED가 전달 되어야 함.
그래야 Overlapped IO 

int WSASend(SOCKET s,LPWSBUF lpBuffer,DWOD dwBufferCount
                   LPDWORD lpNumberOfByteSent,DWOD dw Flags, 
                   LPWSAOVERLAPPED lpOverlapped, 
                   LPWSAOVERLAPPED_COMPLETION_ROUTINE IpCompletionRoutine)
-> 성공시 0 실패시 SOCKET_ERROR 반환

- 소켓의 핸들 전달 Overlapped IO 속성이 부여된 소켓의 핸들 전달시
   Overlapped IO 모델 출력 진행
- 전송할 데이터의 정보를 지니는 WSBUF 구조체 변수들로 이뤄진 배열
   (둘 이상 전송 가능 하단소리)
- 두번째 인자로 전달된 배열의 길이 정보 전달
- 전송된 바이트 수가 저장될 변수의 주소 값 전달 (이는 잠시 후 별도로 설명)
   (오버랩드 아이오여도 데이터 크기가 작을경우에는 의미 있는 값 저장됨.
    샌드 하자마자 완료 될 수 있단 의미 크기가 작아서. 이 경우 WSASend 함수가 0을 반환
    IpnumberOfBytesSent로 전달된 주소의 변수에는 실제 전송된 데이터의 크기 정보가 저장됨.
     
    반환 되기전에 IO가 완료가 되지 않는 다는 가정이 있음. 그런 경우 여기 저장 되는
    값이 의미가 없음.
- 함수의 데이터 전송 특성을 변경하는 경우에 사용 예로 MSG_OOB를 전달하면
  OOB모드 데이터 전송
- WSAOVERLAPPED 구조체 변수의 주소 값 전달 Event 오브젝트를 사용해서
  데이터전송의 완료를 확인하는 경우에 사용 되는 매개 변수
- Completion Routine 이라는 함수의 주소 값 전달 이를 통해 데이터 전송의 완료를
  확인 가능.

WSAsend 함수는 send에 비해 입출력을 완료 할 수 있는 기능이 추가 된 것.

구조체 _WSABUF
{
  u_long len  // 전송할 데이터의 크기
  char FAR *buf // 버퍼의 주소 값
}


구조체 _WSAOVERLAPPEDs
{
  DWOD Internal
  DWOD InternalHigh
  DWOD Offser
  DWOD OffsetHigh
  WSAEVENT hEvent (위 의 네개는 운영체제가 내부적으로 사용이것만 중요히 보면 됨.
   (IO가 끝났을떄 시그널드 상태가 되게 하기 위해서 이벤트 핸들 정보를 담아야함.)
}

WSASend(hSocket,&dataBuf,1,&recvBytes,0,&overlapped,NULL)
               해당 소켓과 연결된 소켓으로 구조체 변수의 버퍼를 참조하여 
               데이터를 전송하고 오버랩드 구조체 변수가 가르키는 구조체의
               이벤트 핸들이 (이벤트오브젝트가) 시그널드 상태로 변함.
               시그널드 상태로 변하는게 오버랩드 아이오를 다른 아이오와 
               구분 되는 장점이구나 구분 할 수 있어야 함.


시그널드가 됬는지 확인하는 도구나 마찬가지인 함수 
(송수신이 완료 됬는지)
BOOL WSAGetOverlappedResult(SOCKET s,LPWSAOVERLAPPED  lpOverlapped,
                                             LPDWORD lpcbTransfer,BOOL fwait
                                             LPDWORD lpdwflags)
-> 성공시 TRUE 실패시 FALSE 반환

- OVERLAPPED IO 가 진행된 소켓의 핸들
- OVERLAPPED IO 진행시 전달한 WSAOVERAPPED 구조체 변수의 주소
- 실제 송수신된 바이트 크기를 저장할 변수의 주소 값 전달
- 여전히 IO가 진행중인 상황의 경우 TRUE 전달시 IO가 완료 될떄까지 대기
   를 하게 되고 FALSE 전달시 FALSE를 반환하면서 함수를 빠져 나온다
- lpdwFlags WSARecv 함수가 호출 된 경우 부수적인 정보(수신된 메세지가
   OOB메세지인지와 같은)를 얻기 위해 사용됨 불필요할시 NULL 전달

WSASend함수 반환을 한 상황에서도 데이터의 전송이 진행되는 상황이면 SOCKET_ERROR을
(실제 에러 상황일때도 SOCKET_ERROR을 반환하지만, 위의 상황에서도 반환)
반환하고 WSAGetLastError 함수 호출을 통해서 확인 가능한 오류 코드는
(위 함수는 진행중이라 소켓에러가 뜨는건지 에러라서 에러가 뜨는건지 확인 가능)
SOCKET_ERROR이 반환되면 오류정보가 메모리에 저장되고 위 함수로 확인 가능)
WSA_IO_PENDING의 등록 된다. 그리고 이경우는 위 함수 호출을 통해서
(펜딩이 나오면 입출력이 완료가 안됬다라는 의미임. 그래서 완료 됬는지
  WSAGetOverlappedResult로 일정시간이 지나던 아니면 확인하고 싶을때
  확인하면 됨.)

실제 전송된 데이터의 크기를 확인 해야함.

int WSArecv(SOCKET s,LPWSBUF lpBuffer,DWOD dwBufferCount
                   LPDWORD lpNumberOfByteRecvd,LPDWOD lpFlags, 
                   LPWSAOVERLAPPED lpOverlapped, 
                   LPWSAOVERLAPPED_COMPLETION_ROUTINE IpCompletionRoutine)

- 소켓의 핸들 전달 Overlapped IO 속성이 부여된 소켓의 핸들 전달시
   Overlapped IO 모델 출력 진행
- 수신할 데이터의 정보를 지니는 WSBUF 구조체 변수들로 이뤄진 배열
   (둘 이상 수신 가능 하단소리)
- 두번째 인자로 전달된 배열의 길이 정보 전달
-  수신된 데이터의 크기 정보 저장될 변수의 주소 값 전달 
- 데이터 전송 특성과 관련된 정보를 지정하거나 수신하는 경우 사용
- WSAOVERLAPPED 구조체 변수의 주소 값 전달 Event 오브젝트를 사용해서
  데이터전송의 완료를 확인하는 경우에 사용 되는 매개 변수
- Completion Routine 이라는 함수의 주소 값 전달 이를 통해 데이터 수신의 완료를
  확인 가능.


리눅스에서 readv와 writev를 이용해서 데이터 송수신을 버퍼에 모아서 한번에 전송 하고 수신 하고 했었는데 이 함수는 윈도우에 없음
WSARecv랑 WSASend는 이를 가능하게 함.



======================Overlapped Io에서의 입출력 완료의 확인

두가지 방법이 있음.

이벤트 오브젝트를 통한 방법  또는 컴플리션 루틴 방법

컴플리션 루틴이란 IO가 완료가 되었을때 호출될 함수를 등록 하는 것.

Event 오브젝트 기반 IO 확인의 중요한 두가지
- IO가 완료 되면 WSAOVERLAPPED 구조체 변수가 참조하는 Event오브젝트가
  signaled 상태가 됨.
- IO의 완료 및 결과를 확인하려면 WSAGetOverlappedResult 함수를 호출 해야함.

WSAGetLastError(void)
-> 오류상황에 대한 상태값(오류의 원인을 알리는 값 반환

오류 발생시 해당 오류 정보를 얻을 수 있음.

WSASend나 Recv를 함수를 호출하면 
반환하면서 송수신이 진행중이거나 에러상황이면 SOCKET_ERROR을 반환함.
이때 그 에러가 WSA_TO_PENDING 상황이면
WSAWaitForMultipleEvents 함수로 시그널드 상태가 될때까지 대기 후 
완료 되면 WSAGetOverlappedResult 함수로 알 수 있음.


Completion Routine 사용하기
- IO가 완료 되었을때 호출되는 함수를 가리켜 Completion Roution 이라 한다.
- IO가 완료 되면 미리 등록된 CompletionRoutine이라 한다.
- Completion Roution이 호출 되기 위해서는 해당 쓰레드가 alertable wait상태에
  놓여야 한다.
- Alertable wait 운영체제가 전달하는 메세지의 수신이 가능한 상태.
  다시 말해서 특별한 일을 진행하지 않는 상태를 뜻한다.

send 함수호출하고 CR을 등록함. 다른일을 열심히 진행중인데 
이제 샌드가 호출이 되었는지 안되었는지는 모름. 아무튼 뭔가
연산이 진행중에 갑자기 호출 되면 안되니 무언가 함수로 
컴플리션 루틴을 실행해도 된다고 메세지를 때려줘야함.

그 상태가 alertable wait 상태임. 

예제의 WSARecv함수의 5번쨰 인자인 WSAOVERLAPPED 구조체는 

구조체 _WSAOVERLAPPED
{
  DWOD Internal
  DWOD InternalHigh
  DWOD Offser
  DWOD OffsetHigh
  WSAEVENT hEvent (위 의 네개는 운영체제가 내부적으로 사용이것만 중요히 보면 됨.
   (IO가 끝났을떄 시그널드 상태가 되게 하기 위해서 이벤트 핸들 정보를 담아야함.)
}

이렇게 되어 있는데 맨 밑에 이벤트 핸들정보를 입력 해야 이 함수의 의의가 있는데
그냥 memset로 초기화(위의 4개가 운영체제가 써야해서)
하고  인자로 넣어줬냐면 overlabbed IO를 사용 할려면
이 구조체 주소를 넣어주는 것이 마이크로 소프트사에서 정한 규칙 이기 때문임.

이 구조체의 주소 값을 안넣으면 블로킹 모드로 동작하는 일반적 소켓으로 간주 됨.

그리고 WSASend 함수를 통해서 동시에 둘 이상의 영역으로 데이터를 전송하는
경우에는 여섯번째 인자로 전달되는 WSAOVERLAPPED 변수를 각각 별도로 구성 해야함.

WSAWaitForMultipleEvents 함수 호출을 위해선 이벤트 오브젝트가 필요한데
이걸 위해 시그널드 상태를 알기 위한 이벤트 오브젝트가 아니고 저 함수 실행을 위해
필요한 이벤트 오브젝트여서 더미 이벤트 오브젝트 라고도 함.

컴플리션 루틴이 반환이 되면 그 이후 코드 영역을 실행함. (실행중엔 멈춘다는 의미인듯)


