TCP상에서 데이터를 주고 받을떄 긴급 메세지를 주고 받을 수 있음.

out-of-band message 

두개의 클라이언트가 서로 데이터를 송수신하는 일반적인 그런것이 아닌
별도의 경로를 통해서 보내는것.

보통 이런경우 긴급한거니까 빠르게 갈 것 같다는 느낌을 받음.

TCP의 특징
1. 전송된 순서대로 감...(긴급 메세지라고해서 빠르게 가버리면 순서유지가 꺠져버림)
 TCP는 어떤 상황에서도 순서를 깨지 않음.
즉 긴급 세팅한다해서 순서는 유지됨.

그렇다면 무슨 의미가 있을까? 

일반적 상황에서의 응급실로 비유하자면

1. 도착이 빨라야함.
2. 병원에서 이 환자는 응급이라는걸 알려야함. (응급조치를 빠르게)

병원이 호스트, 환자는 데이터 도착을 빨리 못했다고 응급이 아닌건 아님
응급환자는 응급 조치를 해야함

즉 TCP에서의 긴급메세지는 어디에 의미가 있냐면 데이터의 도착 즉 송수신에 있어서의 의미는 없음.
이것이 긴급이라는걸 알려서 그 이후의 조치를 촉구 하는것 그것이 TCP의 OOB임.

이 메세지가 도착하면 긴급상황이 발생했다 응급으로 진행하라고 알리는데 의미가 있음.
(호스트간에 약속한)

응급메세지를 받고 나서의 조치는 우리가 조치를 해야함.(함수로 구현을 하던...해서)

TCP에서의 응급은 알리는데 의미가 있음.. 알리는거만... 

이런 응급의 특성(옵션) 같은건 read나 write함수로는 부여 할 수 없었지만

send나 recv는 부여 할 수 있음.


send &recv

MSG_OOB 는 긴급 데이터의 전송을 위한 옶ㄴ
MSG_PEEK 는 데이터를 읽어와도 버퍼에서 사라지지 않는 옵션 (read만 가능)
MSG_Route 입출력 함수 호출과정에서 라우팅 테이블을 참조하지 않을것을 요구함. 로컬 네트워크상에서
             목적지를 찾을때 사용하는 옵션 
MSG_DONTWAIT 입출력 함수 호출과정에서 블로킹 되지 않을것을 요구하기 위한 ㅇㅂ션 


구현법은 OOB가 전달되면 이걸 수신하면 운영체제가 알고 그걸 프로세스에 알려주는데 시그널을 사용함. 
SIGRUG이 발생

state = fcntl(recv_sock,F_SETOWN,getid());
recv_sock : 파일디스크립터
F_SETOWN : 이 소켓의 소유자.
getpid : 현재 프로세스 id가 반환됨.

소켓의 소유자를 pid의 프로세스가 이 소켓의 소유자로 지정이 됨.
getpid가 반환한 pid에 read_sock을 그 프로세스에 소유자를 지정함.


이 소켓을 근거로해서 발생되는 시그널 근거를 getpid로 반환됨 프로세스 아이디에 전달한다 라는 의미.

read_sock를 근거로 OOB가 수신되면 운영체제는 이 프로세스에 전달 해야 겠다 생각됨.

근데 어떤 상황이 있을 수 있냐면 만약 파일디스크립터가 복사가 되어버리면 

하나의 소켓을 두 프로세스가 가지는 경우가 연출 될 수 있음.(fork) 즉 시그널이 발생하면 어느쪽에 줘야 하는가 

난감 할 수 있음.  그래서 이 문장을 지정해줌.  현재 프로세스에 일어났다라고 

OOB가 전달됬을때 해당 호스트가 어찌 아는지도 설명 한 것

★중요함

13챕터 oob_send,recv 예제  890을 OOB옵션 지정해서 보냈는데 0만 읽힌 이유  

입력버퍼에 들어가서 시그널이 발생하고 핸들러가 발생한 순서가

입력버퍼에 남아 있는 89를 읽어들이는 속도보다 조금 빨랐을뿐.
(긴급메세지는 원래 맨 끝에 한바이트감;) 

실행결과를 판단하자면 
1.긴급으로 보냈다해도 보낸 메세지의 양에 관계 없이 1바이트만 반환됨. (맨끝에 있는거 하나만 읽혀짐)
(맨끝에 하나만 주는거면 그냥 긴급을 알리는 의미로 끝임. 나머진 일반적 흐름으로)

2. OOB메세지라고 해서 더 빨리 전송 되지 않음. 

예를들면 긴급메세지는 맨끝에 한바이트만 전송되니  

다른 호스트랑 긴급처리의 약속을 할 수 있음.

호스트1 호스트2 호스트3과 통신을 하는데 긴급조치 일부러 맨끝에 한바이트를 A,B,C로 지정을 해서 
A상황에선 이렇게 B상황에선 이렇게 이런식으로 메세지에 따라 조치를 하자고 약속 가능.

MSG_OOB가 설정되면 Urgent mode모드가 설정됨.

메세지를 보내는거 890을 보내면 890에 다음에 있는 번 인덱스 값을 Urgent 포인터로 지정해줌.

TCP 헤더에도 Urgent모드라고 알려주는게 1이 되고 Urgent 포인터가 같이 저장됨. 그뒤에 데이터가 붙고

send(sock,"890",strlen("890"),MSG_OOB);
890가나다 이런 데이터가 전송된다 싶으면 
890다음번지 인덱스가 Urgent 포인터로 TCP헤더에 붙고 Urgent모드가 있는가 체크해주는게 붙고 
그 다음에 데이터가 붙는데 890 말고 다른 데이터도 같이 보내질 수 있기 때문에 어전트 포인터로 위치를 기억했다
그전에 있는 데이터 1바이트만 핸들러에 의해 리드 했을떄 읽혀지는 데이터로 간주함.

데이터 8 9 0
인덱스 0 1 2 3(3이 Urgent 포인터로 그 앞에 있는 2번지의 0이 긴급모드에 읽히는 데이터로 간주)

MSG_PEEK : 읽어도 버퍼의 내용 안지움
MSG_DONTAWIT : 기다리지 않고 반환함 (블로킹 X)

입력버퍼에 데이터 있는지 없는지 확인하고 읽을 수 있을때만 읽겠다 뭐 이런 의미임. 둘을 같이 쓰면.


===========================================================================================

readv & writev


read와 wtrie는 여러개의 데이터를 읽을려면 여러번 호출을 해야했지만
(서로 다른 배열에 있는 데이터를 송수신 할려면 그 수 만큼 호출 해야 했다)

readv와 writev는 한번에 데이터를 모아서 송수신함.
(서로 다른 공간에 있는 데이터도 한번 호출로 전송 가능)

readv에 첫번쨰 인자에 0을 하면 콘솔로부터 데이터 수신이라 우리가 입력된 값이 저장됨.



성능적으로 (최적화적 측면에서) 3번 호출할걸 한번 호출하게 된다면 좋음으로 
readv나 writev를 사용할 상황이 되면 적극 사용을 권장함.


readv는 둘 이상의 메모리 공간에 한번에 데이터 읽어서 저장 가능
ex) read의 경우에는 read로 둘 이상의 공간에 데이터를 저장 했을때 readv 한번과 결과 같다는뜻.

writev는 둘 이상의 메모리 공간에 한번에 데이터 쓰서 저장 가능.
write 같은 경우는 


장단점
read write는 호출이 간단
v함수는 한번에 모아서 보내야 하기 때문에 준비과정이 필요.
반면 함수호출에 횟수를 줄이는 효과를 가져옴.
버퍼가 비어있을때  write를 여러번 호출하면 그 수만큼 패킷이 가는데 writev는 가급적 하나로 묶어서 보낼려 하기에 패킷 또한 줄어드는 효과가 있다. 수가 줄어든다는건 헤더가 줄어든다는것이기에 송수신의 부담이 적어짐.
(전송속도 향상)




writev(int flags,const struct lovec*iov ,int iovcnt)
1: 파일 디스크립터
2: iovec형 배열의 주소 값
3: 배열의 인덱스 갯수.

iovec형 구조체는 내부적으로
iov_base (버퍼의 주소정보)
iov_len(버퍼의 크기정보)가 저장됨.

하나의 패킷으로 감 ㅎㅎ.




readv 한번의 호출로 입려되는 데이터를 둘 이상의 영역에 나눠서 저장 가능.


readv와 writev 함수는 호출하기전 세팅과정이 너무 귀찮아서. 싫어하는 프로그래머도 있음.
그정돈 알고 있자.

==========================================================================================


윈도우기반에서는 시그널이 없어서.... 조금 다르게 구성해야함.

리눅스에서는 OS가 인지 -> 프로세스에게 알려야함 -> 시그널 발생 -> 프로세스는 그 시그널이 발생했을때 발생될 
핸들러를 만듬. 시그널이 발생됬을때 그 핸들러를 호출하는 구조로 알려줌.

윈도우에서는 이 과정으로 못함.

MSG_OOB는 긴급상황 즉 일반적이지 않음. select함수를 사용.

이걸로 MSG_OOB의 수신을 확인 가능.








