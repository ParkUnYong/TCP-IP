close는 소켓의 완전 소멸을 의미한다.
소켓이 소멸되므로 더 이상의 입 출력은 불가능 하다.
close는 상대방의 상태에 상관없이 일방적인 종료의 형태를 띤다.
때문에 상대 호스트의 데이터 송수신이 아직 완료되지 않은 상황이라면 문제가 발생 할 수 있다.

어떤 문제가 발생하냐면  

A호스트와 B호스트가 있는데  A호스트 입장에서 데이터를 다 보냈다는 확신은 있는데 

반대로 데이터를 수신 받을때 다 받았는가 확신은 못한다.  B입장에서도 

보낼땐 다 보냈다는 확신이 있는데 받을땐 다 받았는지 확신이 없다. 그래서 다 보냈다는 의미로

EOF를 보낸다. 


A입장에서 데이터 다 보내고 close를 호출하고 EOF가 보내줌. 호스트B는 아직 보낼 데이터가 있을 수도 있음.
close를 호출하면 입출력 둘 다 불가능. 

이러한 문제의 대한으로 Half-close 기법이 있다.

전송을 다 했으면 전송만 끄자 수신 할 수 있는 길은 열어두자 

write를 해서 다 읽으면 (송신) half-close를 이용해서 송신 기능만 닫아두고 
수신 기능을 열어둬서 반대쪽에서 EOF를 보낼때까지 냅두는것.

서로 준비된바를 다 송수신하고 끝내기 위해 포핸드쉐이킹.

close함수가 호출되면 이미 포핸드쉐이킹 된것.

소켓의 데이터 송수신은 근간적으로 버퍼 

close를 해도 버퍼에 남아 있는것까진 송수신이 보장 됨.

완전히 종료하면 어플리케이션 레이어에서 write가 불가능.(버퍼에 안들어간 데이터는 보장아 안된다는거인듯.)

헬프 클로즈하면 write가 되서 버퍼로 상대쪽으로 전송 가능. 



